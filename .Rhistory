SetSizes <- rowSums(AllSets)
Found_func <- function(A_temp_index){
A_temp <- nonAT[unlist(possibleSets[A_temp_index,])]
A_temp <- c(A_temp, minA, AT)
R <- MakeR(A_temp, Z, T_decider)
KB <- MakeKB(R, TLevels, 4)
b <- KbSolver(KB, 3)
P_Sigma <- P_SigmaIdentifier(P_Z, KB, b)
ReliableLatesList <- P_Sigma$WA %>%
lapply(function(x) max(x) > ReliabilityCutOff) %>%
unlist() %>% which() %>% names()
degrees <- sapply(TLevels, function(x) sum(grepl(x, ReliableLatesList)))
return(min(degrees))
}
myCluster <- makeCluster(n_cores)
clusterExport(myCluster, c("MakeR", "T_decider", "MakeKB", "KbSolver",
"P_SigmaIdentifier"))
clusterExport(myCluster, c("Z", "TLevels", "P_Z", "minA", "AT",
"ReliabilityCutOff", "nonAT"), envir = environment())
invisible(clusterEvalQ(myCluster, {
library(dplyr)
library(stringr)
}))
while ((maxSize >= 0) & (!Found)) {
possibleSets <- AllSets[SetSizes == maxSize,]
clusterExport(myCluster, c("possibleSets"), envir = environment())
degrees_vec <- parSapply(myCluster, 1:nrow(possibleSets), Found_func)
Found_vec <- (degrees_vec >= minConnections)
Found <- (sum(Found_vec) > 0)
maxSize <- maxSize - 1
}
stopCluster(myCluster)
#ADD A FOR LOOP HERE FOR MORE THAN 1 FOUND SET
foundA <- c(nonAT[unlist(possibleSets[Found_vec,])])
fullA <- GenerateA(TLevels)
fullA <- lapply(fullA, sort)
foundA <- lapply(foundA, sort)
fullA <- fullA[!(fullA %in% foundA)]
fullA <- fullA[!(fullA %in% minA)]
nonAT <- fullA[sapply(fullA, length) > 1]
maxSize <- max(upwardsStep, length(nonAT))
AllSets <- expand.grid(rep(list(c(FALSE, TRUE)), length(nonAT)))
SetSizes <- rowSums(AllSets)
#ADD A FOR LOOP HERE FOR MORE THAN 1 FOUND SET
minA <- c(minA, nonAT[unlist(possibleSets[Found_vec,])])
minA = list(NT_I = c("Ada", "Cer", "Gol", "Eta"),C = c("Inf", "Eta", "Ada", "Cer", "Gol"))
likelyA <- lapply(likelyA, sort)
minA <- lapply(minA, sort)
likelyA <- likelyA[!(likelyA %in% minA)]
nonAT <- likelyA[sapply(likelyA, length) > 1]
AT <- likelyA[sapply(likelyA, length) == 1]
maxSize <- length(nonAT)
Found <- FALSE
AllSets <- expand.grid(rep(list(c(FALSE, TRUE)), maxSize))
SetSizes <- rowSums(AllSets)
Found_func <- function(A_temp_index){
A_temp <- nonAT[unlist(possibleSets[A_temp_index,])]
A_temp <- c(A_temp, minA, AT)
R <- MakeR(A_temp, Z, T_decider)
KB <- MakeKB(R, TLevels, 4)
b <- KbSolver(KB, 3)
P_Sigma <- P_SigmaIdentifier(P_Z, KB, b)
ReliableLatesList <- P_Sigma$WA %>%
lapply(function(x) max(x) > ReliabilityCutOff) %>%
unlist() %>% which() %>% names()
degrees <- sapply(TLevels, function(x) sum(grepl(x, ReliableLatesList)))
return(min(degrees))
}
myCluster <- makeCluster(n_cores)
clusterExport(myCluster, c("MakeR", "T_decider", "MakeKB", "KbSolver",
"P_SigmaIdentifier"))
clusterExport(myCluster, c("Z", "TLevels", "P_Z", "minA", "AT",
"ReliabilityCutOff", "nonAT"), envir = environment())
invisible(clusterEvalQ(myCluster, {
library(dplyr)
library(stringr)
}))
while ((maxSize >= 0) & (!Found)) {
possibleSets <- AllSets[SetSizes == maxSize,]
clusterExport(myCluster, c("possibleSets"), envir = environment())
degrees_vec <- parSapply(myCluster, 1:nrow(possibleSets), Found_func)
Found_vec <- (degrees_vec >= minConnections)
Found <- (sum(Found_vec) > 0)
maxSize <- maxSize - 1
}
stopCluster(myCluster)
#ADD A FOR LOOP HERE FOR MORE THAN 1 FOUND SET
minA <- c(minA, nonAT[unlist(possibleSets[Found_vec,])])
fullA <- GenerateA(TLevels)
fullA <- lapply(fullA, sort)
minA <- lapply(minA, sort)
fullA <- fullA[!(fullA %in% minA)]
nonAT <- fullA[sapply(fullA, length) > 1]
maxSize <- max(upwardsStep, length(nonAT))
AllSets <- expand.grid(rep(list(c(FALSE, TRUE)), length(nonAT)))
SetSizes <- rowSums(AllSets)
minA = list(NT_I = c("Ada", "Cer", "Gol", "Eta"),C = c("Inf", "Eta", "Ada", "Cer", "Gol"))
likelyA <- lapply(likelyA, sort)
minA <- lapply(minA, sort)
likelyA <- likelyA[!(likelyA %in% minA)]
nonAT <- likelyA[sapply(likelyA, length) > 1]
AT <- likelyA[sapply(likelyA, length) == 1]
maxSize <- length(nonAT)
Found <- FALSE
AllSets <- expand.grid(rep(list(c(FALSE, TRUE)), maxSize))
SetSizes <- rowSums(AllSets)
Found_func <- function(A_temp_index){
A_temp <- nonAT[unlist(possibleSets[A_temp_index,])]
A_temp <- c(A_temp, minA, AT)
R <- MakeR(A_temp, Z, T_decider)
KB <- MakeKB(R, TLevels, 4)
b <- KbSolver(KB, 3)
P_Sigma <- P_SigmaIdentifier(P_Z, KB, b)
ReliableLatesList <- P_Sigma$WA %>%
lapply(function(x) max(x) > ReliabilityCutOff) %>%
unlist() %>% which() %>% names()
degrees <- sapply(TLevels, function(x) sum(grepl(x, ReliableLatesList)))
return(min(degrees))
}
myCluster <- makeCluster(n_cores)
clusterExport(myCluster, c("MakeR", "T_decider", "MakeKB", "KbSolver",
"P_SigmaIdentifier"))
clusterExport(myCluster, c("Z", "TLevels", "P_Z", "minA", "AT",
"ReliabilityCutOff", "nonAT"), envir = environment())
invisible(clusterEvalQ(myCluster, {
library(dplyr)
library(stringr)
}))
while ((maxSize >= 0) & (!Found)) {
possibleSets <- AllSets[SetSizes == maxSize,]
clusterExport(myCluster, c("possibleSets"), envir = environment())
degrees_vec <- parSapply(myCluster, 1:nrow(possibleSets), Found_func)
Found_vec <- (degrees_vec >= minConnections)
Found <- (sum(Found_vec) > 0)
maxSize <- maxSize - 1
}
#ADD A FOR LOOP HERE FOR MORE THAN 1 FOUND SET
minA <- c(minA, nonAT[unlist(possibleSets[Found_vec,])])
fullA <- GenerateA(TLevels)
fullA <- lapply(fullA, sort)
minA <- lapply(minA, sort)
fullA <- fullA[!(fullA %in% minA)]
nonAT <- fullA[sapply(fullA, length) > 1]
maxSize <- max(upwardsStep, length(nonAT))
AllSets <- expand.grid(rep(list(c(FALSE, TRUE)), length(nonAT)))
SetSizes <- rowSums(AllSets)
clusterExport(myCluster, c("minA", "nonAT"), envir = environment())
s <- 6
possibleSets <- AllSets[SetSizes == s,]
clusterExport(myCluster, c("possibleSets"), envir = environment())
degrees_vec <- parSapply(myCluster, 1:nrow(possibleSets), Found_func)
Found_vec <- (degrees_vec >= minConnections)
Found <- (sum(Found_vec) > 0)
s <- 5
possibleSets <- AllSets[SetSizes == s,]
clusterExport(myCluster, c("possibleSets"), envir = environment())
degrees_vec <- parSapply(myCluster, 1:nrow(possibleSets), Found_func)
Found_vec <- (degrees_vec >= minConnections)
Found <- (sum(Found_vec) > 0)
s <- 4
possibleSets <- AllSets[SetSizes == s,]
clusterExport(myCluster, c("possibleSets"), envir = environment())
degrees_vec <- parSapply(myCluster, 1:nrow(possibleSets), Found_func)
Found_vec <- (degrees_vec >= minConnections)
Found <- (sum(Found_vec) > 0)
which(Found_vec)
minA <- c(minA, nonAT[unlist(possibleSets[Found_vec,])])
nonAT[unlist(possibleSets[Found_vec,])]
nonAT <- nonAT[!(nonAT %in% minA)]
AllSets <- expand.grid(rep(list(c(FALSE, TRUE)), length(nonAT)))
SetSizes <- rowSums(AllSets)
clusterExport(myCluster, c("minA", "nonAT"), envir = environment())
s <- 4
possibleSets <- AllSets[SetSizes == s,]
clusterExport(myCluster, c("possibleSets"), envir = environment())
degrees_vec <- parSapply(myCluster, 1:nrow(possibleSets), Found_func)
Found_vec <- (degrees_vec >= minConnections)
Found <- (sum(Found_vec) > 0)
s <- 3
possibleSets <- AllSets[SetSizes == s,]
clusterExport(myCluster, c("possibleSets"), envir = environment())
degrees_vec <- parSapply(myCluster, 1:nrow(possibleSets), Found_func)
Found_vec <- (degrees_vec >= minConnections)
Found <- (sum(Found_vec) > 0)
s <- 2
possibleSets <- AllSets[SetSizes == s,]
clusterExport(myCluster, c("possibleSets"), envir = environment())
degrees_vec <- parSapply(myCluster, 1:nrow(possibleSets), Found_func)
Found_vec <- (degrees_vec >= minConnections)
Found <- (sum(Found_vec) > 0)
s <- 1
possibleSets <- AllSets[SetSizes == s,]
clusterExport(myCluster, c("possibleSets"), envir = environment())
degrees_vec <- parSapply(myCluster, 1:nrow(possibleSets), Found_func)
Found_vec <- (degrees_vec >= minConnections)
Found <- (sum(Found_vec) > 0)
stopCluster(myCluster)
c(minA, AT)
nonAT <- nonAT[!(nonAT %in% minA)]
AllSets <- expand.grid(rep(list(c(FALSE, TRUE)), length(nonAT)))
SetSizes <- rowSums(AllSets)
clusterExport(myCluster, c("minA", "nonAT"), envir = environment())
myCluster <- makeCluster(n_cores)
clusterExport(myCluster, c("MakeR", "T_decider", "MakeKB", "KbSolver",
"P_SigmaIdentifier"))
clusterExport(myCluster, c("Z", "TLevels", "P_Z", "minA", "AT",
"ReliabilityCutOff", "nonAT"), envir = environment())
invisible(clusterEvalQ(myCluster, {
library(dplyr)
library(stringr)
}))
s <- 5
s <- 6
possibleSets <- AllSets[SetSizes == s,]
clusterExport(myCluster, c("possibleSets"), envir = environment())
degrees_vec <- parSapply(myCluster, 1:nrow(possibleSets), Found_func)
Found_vec <- (degrees_vec >= minConnections)
Found <- (sum(Found_vec) > 0)
s <- 7
possibleSets <- AllSets[SetSizes == s,]
clusterExport(myCluster, c("possibleSets"), envir = environment())
degrees_vec <- parSapply(myCluster, 1:nrow(possibleSets), Found_func)
Found_vec <- (degrees_vec >= minConnections)
Found <- (sum(Found_vec) > 0)
s <- 16
while((!Found) & (s>0)){
possibleSets <- AllSets[SetSizes == s,]
clusterExport(myCluster, c("possibleSets"), envir = environment())
degrees_vec <- parSapply(myCluster, 1:nrow(possibleSets), Found_func)
Found_vec <- (degrees_vec >= minConnections)
Found <- (sum(Found_vec) > 0)
s <- s-1
}
foundA <- c(minA, AT)
save(foundA, file = "foundA.Rdata")
load("C:/Users/kazem/Dropbox/NESTIMATOR PhD/R Scripts/nestimator2/Nestimator2/.RData")
load("C:/Users/kazem/Dropbox/NESTIMATOR PhD/R Scripts/nestimator2/Nestimator2/foundA.Rdata")
foundR <- MakeR(foundA, Z, T_decider)
foundKB <- MakeKB(foundR, TLevels, 4)
foundb <- KbSolver(foundKB, 3)
foundPis <- PiIdentifier(foundb)
ResMaker <- function(CompleteData, KB = KB, b = b){
P_Z <- MakeP_Z(CompleteData, "Z_value", "trtgrp")
Q_Z <- MakeQ_Z(CompleteData, "Z_value", "trtgrp", "Rem")
P_Sigma <- P_SigmaIdentifier(P_Z, KB, b)
LATEs <- LATEIdentifier(Q_Z, KB, b, P_Sigma)
BSCIs <- BSCICalculator(10000, CompleteData, "Z_value", "trtgrp", "Rem",
KB, b, Cap = TRUE)
ReliableLates <- lapply(LATEs, function(x) x[length(x)])[ReliableLatesList] %>%
unlist() %>% as.data.frame()
ReliableLates$contrast = rownames(ReliableLates)
colnames(ReliableLates) <- c("IV_estimate", "contrast")
rownames(ReliableLates) <- 1:nrow(ReliableLates)
ReliableCIs <- BSCIs$CIs
ReliableCIs$contrast <- rownames(ReliableCIs)
ReliableCIs <- ReliableCIs %>% filter(!(contrast %in% c("Cer_Gol1", "Cer_Gol2"))) %>%
mutate(contrast = ifelse(contrast == "Cer_Gol3", "Cer_Gol", contrast)) %>%
filter(contrast %in% ReliableLatesList)
colnames(ReliableCIs) <- c("IV_conf.low", "IV_conf.high", "contrast")
rownames(ReliableCIs) <- 1:nrow(ReliableCIs)
IV_comparisons <- ReliableLates %>% left_join(ReliableCIs, by = "contrast")
my_base_model <- glm(Rem ~ ., data = CompleteData %>% select(-Z_value), family = "binomial")
my_base_comparisons <- my_base_model %>% marginaleffects::avg_comparisons(variables = list(trtgrp = "pairwise"), type = "response", newdata = "marginalmeans")
for (row in 1:nrow(IV_comparisons)) {
t1 <- IV_comparisons$contrast[row] %>% substr(1,3)
t2 <- IV_comparisons$contrast[row] %>% substr(5,7)
if(paste(t2, "-", t1) %in% my_base_comparisons$contrast){
IV_comparisons$contrast[row] <- paste(t2, "-", t1)
IV_comparisons$IV_estimate[row] <- -IV_comparisons$IV_estimate[row]
temp <- IV_comparisons$IV_conf.low[row]
IV_comparisons$IV_conf.low[row] <- -IV_comparisons$IV_conf.high[row]
IV_comparisons$IV_conf.high[row] <- -temp
}else{
IV_comparisons$contrast[row] <- paste(t1, "-", t2)
}
}
my_comparisons <- my_base_comparisons %>%
select(contrast, estimate, conf.low, conf.high) %>%
left_join(IV_comparisons, by = "contrast") %>%
mutate_if(is.numeric, round, digits = 2) %>%
mutate(R_CI = paste0("(", conf.low, ",", conf.high, ")"),
IV_CI = ifelse(!is.na(IV_estimate), paste0("(", IV_conf.low, ",", IV_conf.high, ")"), "NA")) %>%
select(contrast, estimate, R_CI, IV_estimate, IV_CI)
return(my_comparisons)
}
my_found_comparisons <- CompleteData %>% ResMaker(foundKB, foundb)
foundBSCI <- BSCIs <- BSCICalculator(10000, CompleteData, "Z_value", "trtgrp", "Rem",
foundKB, foundb, Cap = TRUE)
foundBSCI <- BSCIs <- BSCICalculator(10000, CompleteData, "Z_value", "trtgrp", "Rem",
foundKB, foundb, Cap = TRUE)
source("Functions.R")
foundBSCI <- BSCIs <- BSCICalculator(10000, CompleteData, "Z_value", "trtgrp", "Rem",
foundKB, foundb, Cap = TRUE)
foundBSCI <- BSCICalculator(10000, CompleteData, "Z_value", "trtgrp", "Rem",
foundKB, foundb, Cap = TRUE)
remove(foundBSCI)
my_found_comparisons <- CompleteData %>% ResMaker(foundKB, foundb)
View(my_found_comparisons)
P_Sigma <- P_SigmaIdentifier(P_Z, foundKB, foundb)
KB <- foundKB
b <- foundb
load("C:/Users/kazem/Dropbox/NESTIMATOR PhD/R Scripts/nestimator2/Nestimator2/.RData")
load("C:/Users/kazem/Dropbox/NESTIMATOR PhD/R Scripts/nestimator2/Nestimator2/foundA.Rdata")
source("Functions.R")
foundR <- MakeR(foundA, Z, T_decider)
foundKB <- MakeKB(foundR, TLevels, 4)
foundb <- KbSolver(foundKB, 3)
foundPis <- PiIdentifier(foundb)
foundP_Sigma <- P_SigmaIdentifier(P_Z, foundKB, foundb)
foundReliableLatesList <- foundP_Sigma$WA %>%
lapply(function(x) x[length(x)] > 0.1) %>%
unlist() %>% which() %>% names()
foundReliableLatesList
foundReliableLatesList <- foundP_Sigma$WA %>%
lapply(function(x) max(x) > 0.1) %>%
unlist() %>% which() %>% names()
foundReliableLatesList
ReliableLatesList <- P_Sigma$WA %>%
lapply(function(x) max(x) > 0.1) %>%
unlist() %>% which()
ReliableLatesList <- P_Sigma$WA %>%
lapply(function(x) max(x) > 0.1) %>%
unlist() %>% which() %>% names()
P_Sigma$WA %>%
lapply(function(x) max(x) > 0.1) %>%
unlist() %>% which()
LATEs <- LATEIdentifier(Q_Z, foundKB, foundb, foundP_Sigma)
Q_Z <- MakeQ_Z(CompleteData, "Z_value", "trtgrp", "Rem")
LATEs <- LATEIdentifier(Q_Z, foundKB, foundb, foundP_Sigma)
BSCIs <- BSCICalculator(10000, CompleteData, "Z_value", "trtgrp", "Rem",
foundKB, foundb, Cap = TRUE)
BSCIs$CIs
ReliableLates <- lapply(LATEs, function(x) x[length(x)])[foundReliableLatesList] %>%
unlist() %>% as.data.frame()
View(ReliableLates)
lapply(b, rowSums)
b$Ada_Cer
b$Ada_Eta
foundb$Ada_Eta
rowSums(foundb$Ada_Eta)
rowSums(foundb$Ada_Cer)
sum(foundb$Ada_Cer)
dim(foundb$Ada_Cer)
dims(foundb$Ada_Cer)
dim(foundb$Ada_Eta)
dim(foundb$Ada_Cer)
lapply(foundb, function(x){})
lapply(foundb, function(x){
if (is.null(dim(x)))
return(1)
return(which(rowSums(x) == max(rowSums(x))))
})
largestSet <- lapply(foundb, function(x){
if (is.null(dim(x)))
return(1)
return(which(rowSums(x) == max(rowSums(x))))
})
largestSet <- lapply(foundb, function(x){
if (is.null(dim(x)))
return(1)
return(which(rowSums(x) == max(rowSums(x))))
}) %>% unlist()
largestSet
ReliableLates <- lapply(LATEs, function(x) x[length(x)])[foundReliableLatesList] %>%
unlist() %>% as.data.frame()
LATEs[[1]]
name(LATEs[[1]])
names(LATEs[[1]])
lapply(1:length(LATEs), function(x) LATEs[[x]][largestSet[x]])
ReliableLates <- lapply(1:length(LATEs), function(x) LATEs[[x]][largestSet[x]])[ReliableLatesList] %>%
unlist() %>% as.data.frame()
ReliableLates <- lapply(1:length(LATEs), function(x) LATEs[[x]][largestSet[x]])[foundReliableLatesList] %>%
unlist() %>% as.data.frame()
ReliableLates <- lapply(1:length(foundLATEs), function(x) LATEs[[x]][largestSet[x]])[foundReliableLatesList] %>%
unlist() %>% as.data.frame()
KB <- foundKB
b <- foundb
ReliableLatesList <- foundReliableLatesList
P_Sigma <- P_SigmaIdentifier(P_Z, KB, b)
LATEs <- LATEIdentifier(Q_Z, KB, b, P_Sigma)
largestSet <- lapply(b, function(x){
if (is.null(dim(x)))
return(1)
return(which(rowSums(x) == max(rowSums(x))))
}) %>% unlist()
ReliableLates <- lapply(1:length(LATEs), function(x) LATEs[[x]][largestSet[x]])[ReliableLatesList] %>%
unlist() %>% as.data.frame()
lapply(1:length(LATEs), function(x) LATEs[[x]][largestSet[x]])
bla <- lapply(1:length(LATEs), function(x) LATEs[[x]][largestSet[x]])
names(LATEs)
ReliableLates <- lapply(1:length(LATEs), function(x){
y <- LATEs[[x]][largestSet[x]]
names(y) <- names(LATEs)[x]
return(y)
})[ReliableLatesList] %>%
unlist() %>% as.data.frame()
bla <- lapply(1:length(LATEs), function(x){
y <- LATEs[[x]][largestSet[x]]
names(y) <- names(LATEs)[x]
return(y)
})
ReliableLates <- lapply(1:length(LATEs), function(x) LATEs[[x]][largestSet[x]])
names(ReliableLates) <- names(LATEs)
ReliableLates <- ReliableLates[ReliableLatesList] %>%
unlist() %>% as.data.frame()
View(ReliableLates)
ReliableLates$contrast = rownames(ReliableLates)
colnames(ReliableLates) <- c("IV_estimate", "contrast")
rownames(ReliableLates) <- 1:nrow(ReliableLates)
ReliableCIs <- BSCIs$CIs
View(ReliableCIs)
ReliableCIs$contrast <- rownames(ReliableCIs)
foundA
View(ReliableCIs)
ReliableLatesList
largestSet
sapply(ReliableLatesList, function(x){
if(x %in% ReliableCIs$contrast)
})
sapply(ReliableLatesList, function(x){
if(x %in% ReliableCIs$contrast)
return(x)
return(paste0(x, largestSet[x]))
})
whichCIs <- sapply(ReliableLatesList, function(x){
if(x %in% ReliableCIs$contrast)
return(x)
return(paste0(x, largestSet[x]))
})
ReliableCIs <- ReliableCIs %>% filter(contrast %in% whichCIs)
View(ReliableCIs)
ReliableCIs <- BSCIs$CIs
ReliableCIs$contrast <- rownames(ReliableCIs)
whichCIs <- sapply(ReliableLatesList, function(x){
if(x %in% ReliableCIs$contrast)
return(x)
return(paste0(x, largestSet[x]))
})
ReliableCIs <- ReliableCIs %>% filter(contrast %in% whichCIs) %>%
mutate(contrast = gsub('[0-9]+', '', contrast))
colnames(ReliableCIs) <- c("IV_conf.low", "IV_conf.high", "contrast")
rownames(ReliableCIs) <- 1:nrow(ReliableCIs)
IV_comparisons <- ReliableLates %>% left_join(ReliableCIs, by = "contrast")
View(IV_comparisons)
View(ReliableLates)
View(ReliableCIs)
length(LATEs[[1]])
length(LATEs[[2]])
largestSet <- lapply(b, function(x){
if (is.null(dim(x)))
return(1)
return(which(rowSums(x) == max(rowSums(x))))
}) %>% unlist()
ReliableLates <- lapply(1:length(LATEs), function(x) {
if(length(x) == 1)
return(x)
return(LATEs[[x]][largestSet[x]])
})
names(ReliableLates) <- names(LATEs)
ReliableLates <- ReliableLates[ReliableLatesList] %>%
unlist() %>% as.data.frame()
ReliableLates$contrast = rownames(ReliableLates)
colnames(ReliableLates) <- c("IV_estimate", "contrast")
rownames(ReliableLates) <- 1:nrow(ReliableLates)
ReliableCIs <- BSCIs$CIs
ReliableCIs$contrast <- rownames(ReliableCIs)
whichCIs <- sapply(ReliableLatesList, function(x){
if(x %in% ReliableCIs$contrast)
return(x)
return(paste0(x, largestSet[x]))
})
ReliableCIs <- ReliableCIs %>% filter(contrast %in% whichCIs) %>%
mutate(contrast = gsub('[0-9]+', '', contrast))
colnames(ReliableCIs) <- c("IV_conf.low", "IV_conf.high", "contrast")
rownames(ReliableCIs) <- 1:nrow(ReliableCIs)
IV_comparisons <- ReliableLates %>% left_join(ReliableCIs, by = "contrast")
View(IV_comparisons)
largestSet <- lapply(b, function(x){
if (is.null(dim(x)))
return(1)
return(which(rowSums(x) == max(rowSums(x))))
}) %>% unlist()
ReliableLates <- lapply(1:length(LATEs), function(x) {
if(length(LATEs[[x]]) == 1)
return(LATEs[[x]])
return(LATEs[[x]][largestSet[x]])
})
names(ReliableLates) <- names(LATEs)
ReliableLates <- ReliableLates[ReliableLatesList] %>%
unlist() %>% as.data.frame()
ReliableLates$contrast = rownames(ReliableLates)
colnames(ReliableLates) <- c("IV_estimate", "contrast")
rownames(ReliableLates) <- 1:nrow(ReliableLates)
ReliableCIs <- BSCIs$CIs
ReliableCIs$contrast <- rownames(ReliableCIs)
whichCIs <- sapply(ReliableLatesList, function(x){
if(x %in% ReliableCIs$contrast)
return(x)
return(paste0(x, largestSet[x]))
})
ReliableCIs <- ReliableCIs %>% filter(contrast %in% whichCIs) %>%
mutate(contrast = gsub('[0-9]+', '', contrast))
colnames(ReliableCIs) <- c("IV_conf.low", "IV_conf.high", "contrast")
rownames(ReliableCIs) <- 1:nrow(ReliableCIs)
IV_comparisons <- ReliableLates %>% left_join(ReliableCIs, by = "contrast")
View(IV_comparisons)
onlyIV = TRUE
my_found_comparisons <- IV_comparisons %>%
mutate_if(is.numeric, round, digits = 2) %>%
mutate(IV_CI = paste0("(", IV_conf.low, ",", IV_conf.high, ")"))%>%
select(contrast, IV_estimate, IV_CI)
View(my_found_comparisons)
